<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ядро Механизма</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            color: white;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Import map для управления модулями three.js из CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <!-- Основной скрипт приложения -->
    <script type="module">
        // Импорт необходимых модулей из three.js
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        // --- Глобальные переменные ---
        let scene, camera, renderer, controls, composer, clock;
        let core, particles = [], lines, rings, runes = [], outerShell, dataTags = [];
        const PARTICLE_COUNT = 150;
        const RUNE_COUNT = 40;
        const DATA_TAG_COUNT = 30; // Количество пролетающих тегов данных
        const GRID_SIZE = 40;
        const GRID_STEP = 5;
        const CONNECTION_DISTANCE = 8;
        
        // --- Шейдер для ЭЛТ-эффекта (CRT) ---
        const CRTShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'time': { value: 0.0 },
                'scanlineIntensity': { value: 0.2 },
                'glitchIntensity': { value: 0.005 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float time;
                uniform float scanlineIntensity;
                uniform float glitchIntensity;
                varying vec2 vUv;

                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                void main() {
                    vec2 uv = vUv;
                    
                    // Эффект легкого глитча (сдвиг по горизонтали)
                    float glitchTime = floor(time * 5.0);
                    if (random(vec2(glitchTime, 1.0)) > 0.95) {
                       float offset = random(vec2(uv.y, time)) * glitchIntensity;
                       uv.x += offset;
                    }

                    vec4 color = texture2D(tDiffuse, uv);
                    
                    // Эффект строчной развертки (scanlines)
                    float scanline = sin(uv.y * 800.0) * scanlineIntensity;
                    color.rgb -= scanline;
                    
                    gl_FragColor = color;
                }
            `
        };

        // --- Инициализация сцены ---
        function init() {
            // Создание сцены
            scene = new THREE.Scene();
            clock = new THREE.Clock();

            // Создание камеры
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 35;

            // Создание рендерера
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Управление камерой
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 100;

            // Создание центрального ядра
            const coreGeometry = new THREE.OctahedronGeometry(4, 0);
            const coreMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00BFFF, 
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
            core = new THREE.Mesh(coreGeometry, coreMaterial);
            scene.add(core);

            // Создание гироскопических колец
            createRings();

            // Создание частиц
            createParticles();

            // Создание рун
            createRunes();

            // Создание внешней оболочки
            createOuterShell();

            // Создание тегов данных
            createDataTags();

            // Создание линий для соединений
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0x00BFFF,
                transparent: true,
                opacity: 0.3
            });
            const lineGeometry = new THREE.BufferGeometry();
            lines = new THREE.LineSegments(lineGeometry, lineMaterial);
            scene.add(lines);

            // Настройка пост-обработки
            setupPostProcessing();

            // Обработчик изменения размера окна
            window.addEventListener('resize', onWindowResize, false);
        }
        
        // --- Создание гироскопических колец ---
        function createRings() {
            rings = new THREE.Group();
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x7DF9FF, // Более светлый, электрический синий
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });

            const ring1 = new THREE.Mesh(new THREE.TorusGeometry(8, 0.03, 16, 100), ringMaterial);
            ring1.rotation.x = Math.PI / 2;

            const ring2 = new THREE.Mesh(new THREE.TorusGeometry(10, 0.03, 16, 100), ringMaterial);
            
            const ring3 = new THREE.Mesh(new THREE.TorusGeometry(12, 0.03, 16, 100), ringMaterial);
            ring3.rotation.y = Math.PI / 2;

            rings.add(ring1, ring2, ring3);
            scene.add(rings);
        }

        // --- Создание внешней оболочки ---
        function createOuterShell() {
            const shellGeometry = new THREE.IcosahedronGeometry(35, 1);
            const shellMaterial = new THREE.MeshBasicMaterial({
                color: 0x9400D3, // Глубокий фиолетовый
                wireframe: true,
                transparent: true,
                opacity: 0.15
            });
            outerShell = new THREE.Mesh(shellGeometry, shellMaterial);
            scene.add(outerShell);
        }

        // --- Создание тегов данных (ID-меток) ---
        function createDataTags() {
            for (let i = 0; i < DATA_TAG_COUNT; i++) {
                const tagString = generateDataTagString();
                const texture = createDataTagTexture(tagString);

                const material = new THREE.SpriteMaterial({
                    map: texture,
                    color: 0x39FF14, // Кибер-зеленый
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0,
                    depthWrite: false
                });

                const sprite = new THREE.Sprite(material);
                // Делаем их более вытянутыми, как строки текста
                sprite.scale.set(3, 1.5, 1);

                const tag = {
                    sprite: sprite,
                    particleIndex: Math.floor(Math.random() * PARTICLE_COUNT),
                    state: 'hidden', // hidden, fadingIn, visible, fadingOut
                    timer: Math.random() * 7, // Начальная случайная задержка
                    lifespan: Math.random() * 3 + 2, // от 2 до 5 секунд
                    maxOpacity: Math.random() * 0.4 + 0.4 // от 0.4 до 0.8
                };
                
                dataTags.push(tag);
                scene.add(sprite);
            }
        }

        // --- Генерация строки для тега данных ---
        function generateDataTagString() {
            const chars = 'ABCDEF0123456789';
            const prefixes = ['ID:', 'SYS:', 'REG:', 'SEC:', 'DAT:'];
            let result = prefixes[Math.floor(Math.random() * prefixes.length)];
            for (let i = 0; i < 8; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
                if (i === 3) result += '-';
            }
            return result;
        }
        
        // --- Создание текстуры для тега данных ---
        function createDataTagTexture(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(255, 255, 255, 1)';
            context.font = 'bold 32px "Courier New", monospace'; // Моноширинный шрифт для вида "кода"
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 128, 64);
            return new THREE.CanvasTexture(canvas);
        }
        
        // --- Перепривязка тега данных к новой частице ---
        function resetDataTag(tag) {
            tag.particleIndex = Math.floor(Math.random() * PARTICLE_COUNT);
            tag.state = 'hidden';
            tag.timer = Math.random() * 5 + 2; // Время до следующего появления
        }


        // --- Создание неоновых рун ---
        function createRunes() {
            const runeChars = ['ア', 'イ', 'カ', 'キ', 'ク', 'セ', 'ソ', 'タ', 'チ', 'ツ', 'テ', 'ト', 'ノ', 'ハ'];
            for (let i = 0; i < RUNE_COUNT; i++) {
                const char = runeChars[Math.floor(Math.random() * runeChars.length)];
                const texture = createRuneTexture(char);
                
                const material = new THREE.SpriteMaterial({
                    map: texture,
                    color: 0x99FFFF, // Яркий неоновый циан
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0,
                    depthWrite: false
                });

                const sprite = new THREE.Sprite(material);
                
                const rune = {
                    sprite: sprite,
                    state: 'hidden', // hidden, fadingIn, visible, fadingOut
                    timer: Math.random() * 5,
                    lifespan: Math.random() * 2 + 1,
                    maxOpacity: Math.random() * 0.5 + 0.3
                };

                const radius = 15 + Math.random() * 15;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                
                sprite.position.setFromSphericalCoords(radius, phi, theta);
                sprite.scale.set(1.5, 1.5, 1.5);
                
                runes.push(rune);
                scene.add(sprite);
            }
        }

        // --- Вспомогательная функция для текстур рун ---
        function createRuneTexture(character) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(255, 255, 255, 1)';
            context.font = 'bold 96px "Inter", sans-serif';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(character, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        // --- Создание частиц ---
        function createParticles() {
            const circleTexture = createParticleTexture('circle');
            const squareTexture = createParticleTexture('square');

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const isSquare = Math.random() < 0.2;
                const color = isSquare ? 0xFF4136 : 0x00BFFF;
                const texture = isSquare ? squareTexture : circleTexture;

                const material = new THREE.SpriteMaterial({
                    map: texture,
                    color: color,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.8,
                    depthWrite: false
                });

                const sprite = new THREE.Sprite(material);
                const particle = {
                    sprite: sprite,
                    position: new THREE.Vector3(
                        getRandomGridPoint(),
                        getRandomGridPoint(),
                        getRandomGridPoint()
                    ),
                    target: new THREE.Vector3(),
                    speed: Math.random() * 0.01 + 0.01,
                    currentAxis: -1 // -1: не движется, 0:x, 1:y, 2:z
                };

                particle.sprite.position.copy(particle.position);
                particle.sprite.scale.set(0.5, 0.5, 1);
                setNewTarget(particle); // Установить первую цель
                particles.push(particle);
                scene.add(sprite);
            }
        }

        // --- Вспомогательная функция для текстур частиц ---
        function createParticleTexture(shape) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.beginPath();
            if (shape === 'circle') {
                context.arc(32, 32, 30, 0, 2 * Math.PI);
            } else { // square
                context.rect(2, 2, 60, 60);
            }
            context.fillStyle = 'rgba(255,255,255,1)';
            context.fill();
            return new THREE.CanvasTexture(canvas);
        }

        // --- Установка новой цели для частицы ---
        function setNewTarget(particle) {
            const axes = [0, 1, 2].filter(axis => axis !== particle.currentAxis);
            const newAxis = axes[Math.floor(Math.random() * axes.length)];
            
            particle.target.copy(particle.position);
            const newCoordinate = getRandomGridPoint();
            
            if (newAxis === 0) particle.target.x = newCoordinate;
            else if (newAxis === 1) particle.target.y = newCoordinate;
            else particle.target.z = newCoordinate;

            particle.currentAxis = newAxis;
        }
        
        // --- Генерация случайной координаты на сетке ---
        function getRandomGridPoint() {
            const halfGrid = GRID_SIZE / GRID_STEP / 2;
            return (Math.floor(Math.random() * (halfGrid * 2 + 1)) - halfGrid) * GRID_STEP;
        }

        // --- Настройка пост-обработки ---
        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.1, 0.1);
            composer.addPass(bloomPass);

            const crtPass = new ShaderPass(CRTShader);
            crtPass.renderToScreen = true;
            composer.addPass(crtPass);
        }

        // --- Обработчик изменения размера окна ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Анимационный цикл ---
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Вращение ядра
            core.rotation.x += 0.001;
            core.rotation.y += 0.002;
            
            // Вращение внешней оболочки
            if (outerShell) {
                outerShell.rotation.y -= 0.0003;
                outerShell.rotation.x -= 0.0002;
            }

            // Вращение колец в стиле "Сферы Дайсона"
            if (rings) {
                // Медленное, сложное вращение всей группы для эффекта прецессии
                rings.rotation.y += 0.0005;
                rings.rotation.x = Math.sin(time * 0.2) * 0.3;
                rings.rotation.z = Math.cos(time * 0.2) * 0.3;

                // Индивидуальное вращение каждого кольца
                rings.children[0].rotation.z -= 0.005;
                rings.children[1].rotation.y += 0.003;
                rings.children[2].rotation.x -= 0.004;
            }

            // Обновление тегов данных
            dataTags.forEach(tag => {
                // Обновляем позицию тега, чтобы он следовал за частицей
                if (particles[tag.particleIndex]) { // Проверяем, что частица существует
                    const targetParticle = particles[tag.particleIndex];
                    tag.sprite.position.copy(targetParticle.sprite.position);
                    tag.sprite.position.y += 0.8; // Сдвиг вверх, чтобы было над частицей
                }

                const spriteMaterial = tag.sprite.material;

                switch (tag.state) {
                    case 'hidden':
                        tag.timer -= delta;
                        if (tag.timer <= 0) {
                            tag.state = 'fadingIn';
                        }
                        break;
                    case 'fadingIn':
                        spriteMaterial.opacity += delta * 0.8;
                        if (spriteMaterial.opacity >= tag.maxOpacity) {
                            spriteMaterial.opacity = tag.maxOpacity;
                            tag.state = 'visible';
                            tag.timer = tag.lifespan;
                        }
                        break;
                    case 'visible':
                        tag.timer -= delta;
                        if (tag.timer <= 0) {
                            tag.state = 'fadingOut';
                        }
                        break;
                    case 'fadingOut':
                        spriteMaterial.opacity -= delta * 0.8;
                        if (spriteMaterial.opacity <= 0) {
                            spriteMaterial.opacity = 0;
                            resetDataTag(tag); // Перепривязываем к новой частице
                        }
                        break;
                }
            });

            // Обновление рун
            runes.forEach(rune => {
                const spriteMaterial = rune.sprite.material;

                switch (rune.state) {
                    case 'hidden':
                        rune.timer -= delta;
                        if (rune.timer <= 0) {
                            rune.state = 'fadingIn';
                        }
                        break;
                    case 'fadingIn':
                        spriteMaterial.opacity += delta * 0.5;
                        if (spriteMaterial.opacity >= rune.maxOpacity) {
                            spriteMaterial.opacity = rune.maxOpacity;
                            rune.state = 'visible';
                            rune.timer = rune.lifespan;
                        }
                        break;
                    case 'visible':
                        rune.timer -= delta;
                        if (rune.timer <= 0) {
                            rune.state = 'fadingOut';
                        }
                        break;
                    case 'fadingOut':
                        spriteMaterial.opacity -= delta * 0.5;
                        if (spriteMaterial.opacity <= 0) {
                            spriteMaterial.opacity = 0;
                            rune.state = 'hidden';
                            rune.timer = Math.random() * 5 + 2; // Время до следующего появления
                        }
                        break;
                }
            });

            // Обновление частиц
            particles.forEach(p => {
                p.position.lerp(p.target, p.speed);
                p.sprite.position.copy(p.position);

                if (p.position.distanceTo(p.target) < 0.1) {
                    p.position.copy(p.target);
                    setNewTarget(p);
                }
            });

            // Обновление соединительных линий
            const positions = [];
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];
                    const dist = p1.position.distanceTo(p2.position);
                    if (dist < CONNECTION_DISTANCE) {
                        positions.push(p1.position.x, p1.position.y, p1.position.z);
                        positions.push(p2.position.x, p2.position.y, p2.position.z);
                    }
                }
            }
            lines.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            lines.geometry.computeBoundingSphere();
            
            // Обновление контролов и рендеринг
            controls.update();
            composer.passes[2].uniforms.time.value = time; // Обновляем время в шейдере
            composer.render(delta);
        }

        // --- Запуск ---
        init();
        animate();

    </script>
</body>
</html>






