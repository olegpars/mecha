<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ядро Механизма</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            color: white;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Import map для управления модулями three.js из CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <!-- Основной скрипт приложения -->
    <script type="module">
        // Импорт необходимых модулей из three.js
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        // --- Глобальные переменные ---
        let scene, camera, renderer, controls, composer, clock;
        let core, particles = [], lines;
        const PARTICLE_COUNT = 150;
        const GRID_SIZE = 40;
        const GRID_STEP = 5;
        const CONNECTION_DISTANCE = 8;
        
        // --- Шейдер для ЭЛТ-эффекта (CRT) ---
        const CRTShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'time': { value: 0.0 },
                'scanlineIntensity': { value: 0.2 },
                'glitchIntensity': { value: 0.005 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float time;
                uniform float scanlineIntensity;
                uniform float glitchIntensity;
                varying vec2 vUv;

                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                void main() {
                    vec2 uv = vUv;
                    
                    // Эффект легкого глитча (сдвиг по горизонтали)
                    float glitchTime = floor(time * 5.0);
                    if (random(vec2(glitchTime, 1.0)) > 0.95) {
                       float offset = random(vec2(uv.y, time)) * glitchIntensity;
                       uv.x += offset;
                    }

                    vec4 color = texture2D(tDiffuse, uv);
                    
                    // Эффект строчной развертки (scanlines)
                    float scanline = sin(uv.y * 800.0) * scanlineIntensity;
                    color.rgb -= scanline;
                    
                    gl_FragColor = color;
                }
            `
        };

        // --- Инициализация сцены ---
        function init() {
            // Создание сцены
            scene = new THREE.Scene();
            clock = new THREE.Clock();

            // Создание камеры
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 35;

            // Создание рендерера
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Управление камерой
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 100;

            // Создание центрального ядра
            const coreGeometry = new THREE.OctahedronGeometry(4, 0);
            const coreMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00BFFF, 
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
            core = new THREE.Mesh(coreGeometry, coreMaterial);
            scene.add(core);

            // Создание частиц
            createParticles();

            // Создание линий для соединений
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0x00BFFF,
                transparent: true,
                opacity: 0.3
            });
            const lineGeometry = new THREE.BufferGeometry();
            lines = new THREE.LineSegments(lineGeometry, lineMaterial);
            scene.add(lines);

            // Настройка пост-обработки
            setupPostProcessing();

            // Обработчик изменения размера окна
            window.addEventListener('resize', onWindowResize, false);
        }
        
        // --- Создание частиц ---
        function createParticles() {
            const circleTexture = createParticleTexture('circle');
            const squareTexture = createParticleTexture('square');

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const isSquare = Math.random() < 0.2;
                const color = isSquare ? 0xFF4136 : 0x00BFFF;
                const texture = isSquare ? squareTexture : circleTexture;

                const material = new THREE.SpriteMaterial({
                    map: texture,
                    color: color,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.8,
                    depthWrite: false
                });

                const sprite = new THREE.Sprite(material);
                const particle = {
                    sprite: sprite,
                    position: new THREE.Vector3(
                        getRandomGridPoint(),
                        getRandomGridPoint(),
                        getRandomGridPoint()
                    ),
                    target: new THREE.Vector3(),
                    speed: Math.random() * 0.01 + 0.01,
                    currentAxis: -1 // -1: не движется, 0:x, 1:y, 2:z
                };

                particle.sprite.position.copy(particle.position);
                particle.sprite.scale.set(0.5, 0.5, 1);
                setNewTarget(particle); // Установить первую цель
                particles.push(particle);
                scene.add(sprite);
            }
        }

        // --- Вспомогательная функция для текстур частиц ---
        function createParticleTexture(shape) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.beginPath();
            if (shape === 'circle') {
                context.arc(32, 32, 30, 0, 2 * Math.PI);
            } else { // square
                context.rect(2, 2, 60, 60);
            }
            context.fillStyle = 'rgba(255,255,255,1)';
            context.fill();
            return new THREE.CanvasTexture(canvas);
        }

        // --- Установка новой цели для частицы ---
        function setNewTarget(particle) {
            const axes = [0, 1, 2].filter(axis => axis !== particle.currentAxis);
            const newAxis = axes[Math.floor(Math.random() * axes.length)];
            
            particle.target.copy(particle.position);
            const newCoordinate = getRandomGridPoint();
            
            if (newAxis === 0) particle.target.x = newCoordinate;
            else if (newAxis === 1) particle.target.y = newCoordinate;
            else particle.target.z = newCoordinate;

            particle.currentAxis = newAxis;
        }
        
        // --- Генерация случайной координаты на сетке ---
        function getRandomGridPoint() {
            const halfGrid = GRID_SIZE / GRID_STEP / 2;
            return (Math.floor(Math.random() * (halfGrid * 2 + 1)) - halfGrid) * GRID_STEP;
        }

        // --- Настройка пост-обработки ---
        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.1, 0.1);
            composer.addPass(bloomPass);

            const crtPass = new ShaderPass(CRTShader);
            crtPass.renderToScreen = true;
            composer.addPass(crtPass);
        }

        // --- Обработчик изменения размера окна ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Анимационный цикл ---
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Вращение ядра
            core.rotation.x += 0.001;
            core.rotation.y += 0.002;
            
            // Обновление частиц
            particles.forEach(p => {
                p.position.lerp(p.target, p.speed);
                p.sprite.position.copy(p.position);

                if (p.position.distanceTo(p.target) < 0.1) {
                    p.position.copy(p.target);
                    setNewTarget(p);
                }
            });

            // Обновление соединительных линий
            const positions = [];
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];
                    const dist = p1.position.distanceTo(p2.position);
                    if (dist < CONNECTION_DISTANCE) {
                        positions.push(p1.position.x, p1.position.y, p1.position.z);
                        positions.push(p2.position.x, p2.position.y, p2.position.z);
                    }
                }
            }
            lines.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            lines.geometry.computeBoundingSphere();
            
            // Обновление контролов и рендеринг
            controls.update();
            composer.passes[2].uniforms.time.value = time; // Обновляем время в шейдере
            composer.render(delta);
        }

        // --- Запуск ---
        init();
        animate();

    </script>
</body>
</html>
